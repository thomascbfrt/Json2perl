import { DataSet, Edge, Network, Node, Options } from 'vis-network/standalone';
import { EventEmitter } from '@angular/core';

import { Project } from './project.model';
import { Topic } from './topic.model';
import { Group } from './group.model';
import { User } from './user.model';

interface NodeGraph extends Node {
  data?: {
    id: string;
  };
  type?: string | number;
}

interface EdgeGraph extends Edge {
  data?: any;
}

export enum NodeShape {
  SQUARE = 'square',
  IMAGE = 'image',
  CIRCULAR_IMAGE = 'circularImage',
  DIAMOND = 'diamond',
  DOT = 'dot',
  STAR = 'star',
  TRIANGLE = 'triangle',
  TRIANGLE_DOWN = 'triangleDown',
  HEXAGON = 'hexagon',
  ICON = 'icon',
}

export enum NodeType {
  PROJECT,
  USER,
  GROUP,
  SUBJECT,
}

enum NodeColor {
  PROJECT = '#E0AC54',
  USER = '#78B1DD',
  GROUP = '#55D764',
}

export enum EdgeType {
  FROM,
  TO,
  NONE,
}

/**
 * GraphForge
 *
 * Lightweight wrapper around vis-network to create, connect and manipulate
 * a typed graph (projects, topics, groups, users).
 *
 * The wrapper manages datasets (nodes/edges), applies a default display/physics
 * configuration and provides utilities to generate/parse internal identifiers
 * as well as domain-specific helper methods.
 *
 * Notes:
 * - Internal identifiers follow the format "=={type}=={id}==". Several helpers
 *   (generateID, getNodeType, getNodeID, getNodesIDByType) rely on this format.
 * - An internal Map (resisted_edges) prevents adding duplicate edges (bidirectional key).
 * - Methods that return EventEmitter expose an Angular emitter that emits the
 *   identifier of the selected or double-clicked node.
 */
export class GraphForge {
  private readonly _config: Options = {
    nodes: {
      font: { color: '#333', size: 16 },
      borderWidth: 2,
    },
    edges: {
      font: { align: 'middle' },
      arrows: { to: { enabled: true, scaleFactor: 0.7 } },
      color: { color: '#888', highlight: '#000' },
    },
    physics: {
      enabled: true,
      stabilization: { iterations: 100 },
    },
    interaction: {
      hover: true,
      dragNodes: true,
      zoomView: true,
      multiselect: true,
    },
  };

  private readonly _network;

  private readonly resisted_edges = new Map<string, string>();
  private readonly dataSet_nodes = new DataSet<NodeGraph>();
  private readonly dataSet_edges = new DataSet<EdgeGraph>();
  private readonly ref_nodes = new Map<NodeShape, Map<number, string>>();
  private readonly reverse_ref_node = new Map<string, { type: NodeShape; id: number }>();

  constructor(container: HTMLElement) {
    this._network = new Network(
      container,
      { nodes: this.dataSet_nodes, edges: this.dataSet_edges },
      this._config
    );
  }

  /**
   * Initializes the physics solver in repulsion mode and sets the minimum
   * distance between nodes.
   *
   * @param distance - Target distance between nodes used by the repulsion solver.
   */
  setRepultion(distance: number): void {
    this._network.setOptions({
      physics: {
        solver: 'repulsion',
        repulsion: {
          nodeDistance: distance,
        },
      },
    });
  }

  /**
   * Creates and adds a typed node to the internal DataSet.
   *
   * The node uses an internal identifier generated by generateID(type, data.id).
   * If a node with the same identifier already exists, the method returns that
   * identifier and does not add a duplicate.
   *
   * @param label - Visible label of the node.
   * @param type - Numeric discriminator corresponding to NodeType.
   * @param shape - Visual shape of the node (NodeShape).
   * @param color - Node background color (hex or CSS color).
   * @param data - Optional payload associated with the node (domain model).
   * @param size - Optional size modifier (default 0).
   * @returns The internal identifier of the added node (format "=={type}=={id}==").
   */
  createNode(
    label: string,
    type: number,
    shape: NodeShape,
    color: string,
    data?: any,
    size: number = 0
  ): string {
    const node: NodeGraph = {
      id: this.generateID(type, data.id),
      label: label,
      type: type,
      shape: shape,
      color: {
        background: color,
        border: '#000000',
      },
      data: data,
      size: 50 + size * 2,
    };
    if (this.dataSet_nodes.getIds().includes(node.id!)) {
      return node.id as string;
    }

    const id = this.dataSet_nodes.add(node)[0];
    return id as string;
  }

  /**
   * Generates a uniform internal identifier for a node.
   *
   * The format used is: "=={type}=={id}==".
   *
   * @param type - Numeric NodeType.
   * @param id - Domain model identifier (converted to a string).
   * @returns The formatted identifier.
   */
  generateID(type: number, id: string): string {
    return `==${type}==${id}==`;
  }

  /**
   * Connects two nodes with an edge in the internal DataSet.
   *
   * Duplicate edges are avoided using the internal Map resisted_edges which stores
   * a bidirectional key. The 'type' parameter controls the direction of the arrows.
   *
   * @param id_1 - Internal identifier of the target node (to).
   * @param id_2 - Internal identifier of the source node (from).
   * @param type - Edge type (EdgeType) controlling the direction of the arrows.
   */
  connectNodes(id_1: string, id_2: string, type: EdgeType = EdgeType.NONE): void {
    if (
      this.resisted_edges.has(`||${id_1}||${id_2}||`) ||
      this.resisted_edges.has(`||${id_2}||${id_1}||`)
    )
      return;
    const id = this.dataSet_edges.add({
      to: id_1,
      from: id_2,
      arrows: {
        from: type === EdgeType.FROM || false,
        to: type === EdgeType.TO || false,
      },
    })[0] as string;

    this.resisted_edges.set(`||${id_1}||${id_2}||`, id);
    this.resisted_edges.set(`||${id_2}||${id_1}||`, id);
  }

  /**
   * Removes all nodes, edges and clears internal reference maps.
   *
   * Used to completely reset the graph state.
   */
  clear(): void {
    this.dataSet_edges.clear();
    this.dataSet_nodes.clear();
    this.ref_nodes.clear();
    this.reverse_ref_node.clear();
  }

  /**
   * Retrieves the identifiers of the nodes currently selected in the network.
   *
   * @returns Array of internal identifiers of the selected nodes.
   */
  getSelectedNodes(): string[] {
    return this._network.getSelectedNodes() as string[];
  }

  /**
   * Extracts the "type" portion from an internal identifier.
   *
   * The expected format is "=={type}=={id}==". For invalid formats the behavior
   * depends on the provided string (may return NaN if converted later).
   *
   * @param id - Internal node identifier.
   * @returns The numeric type parsed from the identifier.
   */
  getNodeType(id: string): number {
    const r = id.split('==').slice(1, 3);
    let type = r[0];

    return type as unknown as number;
  }

  /**
   * Extracts the "id" portion (domain model identifier) from an internal identifier.
   *
   * The expected format is "=={type}=={id}==". For invalid formats the behavior
   * will depend on the provided string (it may return NaN if parsed later).
   *
   * @param id - Internal node identifier.
   * @returns The domain model identifier as a parsed number.
   */
  getNodeID(id: string): number {
    const r = id.split('==').slice(1, 3);
    let elt_id = r[1];

    return elt_id as unknown as number;
  }

  /**
   * Provides an EventEmitter that emits the identifier of the double-clicked node.
   *
   * The returned EventEmitter emits a string containing the internal identifier
   * of the node that the user double-clicked.
   *
   * @returns EventEmitter<string> emitting the internal node identifier.
   */
  onNodeDoubleClick(): EventEmitter<string> {
    const event = new EventEmitter<string>();
    const temp = new EventEmitter<string>();
    temp.subscribe((id) => {
      event.emit(id);
    });
    this._network.on('doubleClick', (e) => {
      temp.emit(e.nodes[0]);
    });

    return event;
  }

  /**
   * Provides an EventEmitter that emits the identifier of the selected node.
   *
   * The returned EventEmitter emits a string corresponding to the internal
   * identifier of the node selected by the user.
   *
   * @returns EventEmitter<string> emitting the internal node identifier.
   */
  onNodeSelect(): EventEmitter<string> {
    const event = new EventEmitter<string>();
    const temp = new EventEmitter<string>();
    temp.subscribe((id) => {
      event.emit(id);
    });
    this._network.on('selectNode', (e) => {
      temp.emit(e.nodes[0]);
    });

    return event;
  }

  /**
   * Removes a node identified by its internal identifier from the DataSet.
   *
   * @param id - Internal identifier of the node to remove.
   */
  removeNode(id: string): void {
    this.dataSet_nodes.remove(id);
  }

  /**
   * Retrieves the payload (the `data` property) associated with a node.
   *
   * @param id - Internal node identifier.
   * @returns The payload stored in the node or undefined if absent.
   */
  getNodeDataByID(id: string): any {
    return (this.dataSet_nodes.get(id) as NodeGraph).data;
  }

  /**
   * Programmatically selects a node in the network UI.
   *
   * @param id - Internal identifier of the node to select.
   */
  selectNode(id: string): void {
    this._network.selectNodes([id]);
  }

  /**
   * Returns the identifiers (extracted and parsed) of nodes matching a given type.
   *
   * This method filters internal nodes by NodeType and returns an array of domain
   * ids (the {id} part in "=={type}=={id}==").
   *
   * @param type - Numeric NodeType to filter by.
   * @returns Array of domain identifiers (as numbers) matching the type.
   */
  getNodesIDByType(type: number): number[] {
    let nodes: NodeGraph[] = this.dataSet_nodes.get();

    nodes = nodes.filter((n) => (n.id?.toString().split('==')[1] as unknown as number) == type);

    return nodes.map((n) => n.id!.toString().split('==')[2] as unknown as number);
  }

  /**
   * Recenters and adjusts the network zoom to display the entire graph.
   *
   * The operation uses an animation to perform the fit.
   */
  fit(): void {
    this._network.fit({
      animation: {
        duration: 2000,
        easingFunction: 'easeOutCubic',
      },
    });
  }

  /**
   * Centers and focuses on a given node.
   *
   * @param id - Internal identifier of the node to focus.
   */
  focus(id: string): void {
    this._network.focus(id);
  }

  /**
   * Creates a PROJECT type node using the visual conventions and
   * stores the Project model as the node payload.
   *
   * Wrapper around createNode with NodeType.PROJECT and default visual parameters.
   *
   * @param project - Project object containing at minimum an id and a name.
   * @param size - Optional size modifier.
   * @returns The internal identifier of the created project node.
   */
  public createProject(project: Project, size?: number): string {
    return this.createNode(
      project.name,
      NodeType.PROJECT,
      NodeShape.SQUARE,
      NodeColor.PROJECT,
      project,
      size
    );
  }

  /**
   * Creates a SUBJECT (topic) node using the visual conventions and
   * stores the Topic model as the node payload.
   *
   * Wrapper around createNode with NodeType.SUBJECT and default visual parameters.
   *
   * @param topic - Topic object containing at minimum an id and a name.
   * @param size - Optional size modifier.
   * @returns The internal identifier of the created topic node.
   */
  public createTopic(topic: Topic, size?: number): string {
    return this.createNode(
      topic.name,
      NodeType.SUBJECT,
      NodeShape.HEXAGON,
      NodeColor.GROUP,
      topic,
      size
    );
  }

  /**
   * Creates a GROUP node using the visual conventions and
   * stores the Group model as the node payload.
   *
   * Wrapper around createNode with NodeType.GROUP and default visual parameters.
   *
   * @param group - Group object containing at minimum an id and a name.
   * @param size - Optional size modifier.
   * @returns The internal identifier of the created group node.
   */
  public createGroup(group: Group, size?: number): string {
    return this.createNode(
      group.name,
      NodeType.GROUP,
      NodeShape.TRIANGLE,
      NodeColor.GROUP,
      group,
      size
    );
  }

  /**
   * Creates a USER type node using the visual conventions and
   * stores the User model as the node payload.
   *
   * Wrapper around createNode with NodeType.USER and default visual parameters.
   *
   * @param user - User object containing at minimum an id and a name.
   * @param size - Optional size modifier.
   * @returns The internal identifier of the created user node.
   */
  public createUser(user: User, size?: number): string {
    return this.createNode(user.name, NodeType.USER, NodeShape.DOT, NodeColor.USER, user, size);
  }
}
